# -*- coding: utf-8 -*-
"""SMC_Backstepping.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YbrWqhGk4zteiQYc7II9MiNbmocY3lmk
"""

import matplotlib.pyplot as plt
import numpy as np
from numpy import sin as S 
from numpy import cos as C 
from numpy import tan as T
from numpy.core.shape_base import block 
from scipy.linalg import block_diag

class controller:
        def __init__(self):
                self.x, self.y, self.z, self.xdot, self.ydot, self.zdot, self.theta, self.phi, self.sci, self.thetadot, self.scidot, self.phidot = np.array([0]),np.array([0]),np.array([0]),np.array([0]),np.array([0]),np.array([0]),np.array([0]),np.array([0]),np.array([0]),np.array([0]),np.array([0]),np.array([0]) 
                self.x5d = np.array([0]) 
                self.x5dot = np.array([0])
                self.g = 9.81
                self.m = 2.0
                self.Jx, self.Jy = 0.018125, 0.018125
                self.Jz = 0.035
                self.Jr = 6*0.001
                self.Jb = np.diag([self.Jx,self.Jy,self.Jz])
                self.omegabar = 1     ###to be tuned
                self.k1, self.k2, self.k3 = 3, 4, 1   ###to be tuned
                self.c1, self.c2, self.c3, self.c4, self.c5, self.c6, self.c7, self.c8, self.c9, self.c10 = 5, 10, 12, 7, 6, 8, 9, 11, 15, 8
                self.x1ddotdot, self.x3ddotdot, self.x5ddotdot = np.array([0]), np.array([0]), np.array([0])
                self.dphi, self.dtheta, self.dsci = 1.2, 1.2, 1.2
                self.dx, self.dy, self.dz = .03, .01, .03
                self.x3ddot = 0
                self.rho1, self.rho2, self.rho3, self.rho4, self.rho5, self.rho6 = 1,0.1,0.01,0.1,0.0001,0.1 #to be tuned 
                self.dt = 0.1
                self.t = 0.0
                self.U1, self.U2, self.U3, self.U4 = np.array([0]),np.array([0]),np.array([0]),np.array([0])
                ####
                self.x3dot = 0
                self.x5dot = 0
                self.x5ddot = 0
                self.v1o,self.v2o,self.v3o,self.v4o,self.v5o,self.v6o = np.array([0.0]),np.array([0.0]),np.array([0.0]),np.array([0.0]),np.array([0.0]),np.array([0.0])
                self.x5d = np.array([0])
                self.x5ddot = np.array([0])
                self.x7ddot, self.x7d = np.array([0]), np.array([0])
                self.x9ddot, self.x9d = np.array([0]), np.array([0])
                self.x11d = np.array([0])
                self.x11ddot = np.array([0])
                self.v1,self.v2,self.v3,self.v4,self.v5,self.v6 = np.array([0.0]),np.array([0.0]),np.array([0.0]),np.array([0.0]),np.array([0.0]),np.array([0.0])

        def calc_input(self):
                self.v1 = self.x7ddot + self.rho1*(self.x7d - self.x7)
                self.v1dot = self.derivative(self.v1,self.v1o)
                self.v2 = self.v1dot + (self.x7d - self.x7) + self.a9*self.x8 + self.rho2*(self.v1-self.x8)
                self.v3 = self.x9ddot + self.rho3*(self.x9d-self.x9)
                self.v3dot = self.derivative(self.v3,self.v3o) 
                self.v4 = self.v3dot + (self.x9d - self.x9) + self.a10*self.x10 + self.rho4*(self.v3 - self.x10)
                self.v5 = self.x11ddot + self.rho5*(self.x11d - self.x11) 
                self.v5dot = self.derivative(self.v5,self.v5o) 
                self.v6 = self.v5dot + (self.x11d - self.x11) + self.g + self.a11*self.x12 + self.rho6*(self.v5 - self.x12)

                #desired states
                np.seterr(invalid='ignore')
                a = C(self.x5d)
                b = S(self.x5d)
                c = np.divide(np.sum(self.v2 + self.v4),self.v6)
                d = a + b
                self.x1d = np.arctan(a*c*self.v6-d*self.v4/(a*self.v6*np.sqrt(c**2 + d**2)))
                self.x3d = np.arctan(c/d)
                self.z1 = self.x1d - self.x1
                self.x1ddot = 0
                self.z1dot = self.x1ddot - self.x1dot
                self.z3 = self.x3d - self.x3
                self.z3dot = self.x3ddot - self.x3dot
                self.z5 = self.x5d - self.x5
                self.z5dot = self.x5ddot - self.x5dot
                self.U4 = (a**2*(c**2+d**2)*self.v6**2 + (a*c*self.v6 - d*self.v4)**2)/(a*d)
                self.U1 = self.x1ddotdot + self.c1*(self.z1dot) - (self.a1*self.x4*self.x6 + self.a2*self.omegabar*self.x4 - self.a3*self.x2) + self.k1*np.sign(self.z1dot + self.c1*self.z1)
                self.U2 = self.x3ddotdot + self.c2*(self.z3dot) - (self.a4*self.x2*self.x6 + self.a5*self.omegabar*self.x2 - self.a6*self.x4) + self.k2*np.sign(self.z3dot + self.c4*self.z3)
                self.U3 = self.x5ddotdot + self.c3*(self.z5dot) - (self.a7*self.x2*self.x4  - self.a8*self.x6) + self.k3*np.sign(self.z5dot + self.c10*self.z5)
                print(f"\n{a} + { b} + {c} + {d}")
        def integrate(self,q1,q2):
                return q2*self.dt + q1

        def derivative(self,q1,q2):
                return (q1-q2)/self.dt

        def update(self):
                #introduction of all states and control inputs      
                self.x1 = self.phi
                self.x2 = self.phidot
                self.x3 = self.theta
                self.x4 = self.thetadot
                self.x5 = self.sci
                self.x6 = self.scidot
                self.x7 = self.x
                self.x8 = self.xdot
                self.x9 = self.y
                self.x10 = self.ydot
                self.x11 = self.z
                self.x12 = self.zdot

                
                #value of constant ai
                self.a1 = (self.Jy-self.Jz)/self.Jx
                self.a2 = (self.Jr)/self.Jx
                self.a3 = self.dphi/self.Jx
                self.a4 = (self.Jz-self.Jx)/self.Jy
                self.a5 = self.Jr/self.Jy
                self.a6 = self.dphi/self.Jy
                self.a7 = (self.Jx-self.Jy)/self.Jz
                self.a8 = self.dsci/self.Jz
                self.a9 = self.dx/self.m
                self.a10 = self.dy/self.m
                self.a11 = self.dz/self.m 
                #differential parameters
                self.x1dot = self.x2
                self.x2dot = self.a1*self.x4*self.x6 + self.a2*self.omegabar*self.x4 - self.a3*self.x2 + self.U1
                self.x3dot = self.x4
                self.x4dot = self.a4*self.x2*self.x6 + self.a5*self.omegabar*self.x2 - self.a6*self.x2 + self.U3
                self.x5dot = self.x6
                self.x6dot = self.a7*self.x2*self.x4 - self.a8*self.x6 + self.U3
                self.x7dot = self.x8
                self.x8dot = (C(self.x1)*S(self.x3)*C(self.x5) + S(self.x1)*S(self.x5))*self.U4 - self.a9*self.x8
                self.x9dot = self.x10
                self.x10dot = (C(self.x1)*S(self.x3)*C(self.x5) + S(self.x1)*S(self.x5))*self.U4 - self.a10*self.x10
                self.x11dot = self.x12
                self.x12dot = -self.g + (C(self.x1)*C(self.x3))*self.U4 - self.a11*self.x12

                

        def compute(self):
                T = np.linspace(0,20,200)
                self.update()

                plt.figure(figsize=(10,5))
                ax = plt.axes(projection ='3d')

                for i in range(1,20):
                        self.t = T[i]
                        self.v1o,self.v2o,self.v3o,self.v4o,self.v5o,self.v6o = np.copy(self.v1),np.copy(self.v2),np.copy(self.v3),np.copy(self.v4),np.copy(self.v5),np.copy(self.v6)
                        self.x5d = np.array([0])
                        self.x5ddot = np.array([0])
                        self.x7ddot, self.x7d = np.array([0]), np.array([0])
                        self.x9ddot, self.x9d = np.array([0]), np.array([0])
                        self.x11d = np.array([0.5*S(self.t)])
                        self.x11ddot = np.array([0.5*C(self.t)])
                        self.calc_input()
                        
                        self.phi = self.integrate(self.x1,self.x1dot)
                        self.phidot = self.integrate(self.x2,self.x2dot)
                        self.theta = self.integrate(self.x3,self.x3dot)
                        self.thetadot = self.integrate(self.x4,self.x4dot)
                        self.sci = self.integrate(self.x5,self.x5dot)
                        self.scidot = self.integrate(self.x6,self.x6dot)
                        self.x = self.integrate(self.x7,self.x7dot)
                        self.xdot = self.integrate(self.x8,self.x8dot)
                        self.y = self.integrate(self.x9,self.x9dot)
                        self.ydot = self.integrate(self.x10,self.x10dot)
                        self.z = self.integrate(self.x11,self.x11dot)
                        self.zdot = self.integrate(self.x12,self.x12dot)
                        self.update()

                        #print(f"{self.x} {self.y } { self.z}")
                        print(f"{self.z}\n {self.U4}\n {self.x12}\n  {self.v5dot}\n {self.v6}")
                        ax.plot(self.x, self.y, self.z, c='lightblue',marker='o')
                        ax.plot(0, 0, 10*S(self.t), c='red',marker='o')
                        plt.show(block=False)
                        plt.pause(1)
                plt.show()
if __name__ == '__main__':
        nlc = controller()
        nlc.compute()